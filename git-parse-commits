#!/usr/bin/env python3
#
# Copyright 2024 Igor Stepin <igor_for_os@stepin.name>.
# Licensed under the MIT license (https://opensource.org/licenses/MIT).
#
#
import argparse
import dataclasses
from enum import Enum
import functools
import operator
import re
import subprocess
import sys
import json
from dataclasses import dataclass
from typing import List, Optional


class IncrementType(str, Enum):
    NONE = "none"
    PATCH = "patch"
    MINOR = "minor"
    MAJOR = "major"


@dataclass
class VersionInfo:
    last: Optional[str]
    increment: IncrementType
    current: str


@dataclass
class RawCommit:
    commit: str
    author: Optional[str]
    author_email: Optional[str]
    date: str
    message: str
    epoch: int
    epoch_utc: Optional[int]

    @classmethod
    def from_dict(cls, data):
        return cls(
            commit=data.get("commit"),
            author=data.get("author"),
            author_email=data.get("author_email"),
            date=data.get("date"),
            message=data.get("message"),
            epoch=data.get("epoch"),
            epoch_utc=data.get("epoch_utc"),
        )


@dataclass
class ChangeLogLine:
    type: str
    scope: str
    description: str
    group: Optional[str]
    increment: IncrementType


@dataclass
class CommitInfo:
    commit: str
    author: Optional[str]
    author_email: Optional[str]
    date: str
    raw: str
    headers: List[ChangeLogLine]
    notes: dict[str, str]


@dataclass
class ParsedInfo:
    version: VersionInfo
    commits: List[CommitInfo]


class EnhancedJSONEncoder(json.JSONEncoder):
    def default(self, o):
        if dataclasses.is_dataclass(o):
            return dataclasses.asdict(o)
        return super().default(o)


def run(cmd) -> str:
    result = subprocess.run(
        cmd,
        stdout=subprocess.PIPE,
        stderr=subprocess.STDOUT,
        universal_newlines=True,
    )
    if result.returncode != 0:
        print("fatal: failed command %s" % cmd)
        print("output: %s" % result.stdout)
        print("tip: most common reason: incorect git commit sha")
        sys.exit(2)
    return result.stdout.strip()


def version_command(as_json: bool):
    version = "SNAPSHOT"
    if as_json:
        print('{"tool_version": "%s"}' % version)
    else:
        print(version)


def current_version_command(
    as_json: bool,
    tag_prefix: Optional[str],
    as_tag: bool,
    last_revision: Optional[str],
):
    if not last_revision:
        last_revision = "HEAD"
    if tag_prefix is None:
        version = run(["git", "describe", "--tags", "--always", last_revision])
    else:
        version = run(
            [
                "git",
                "describe",
                "--tags",
                "--always",
                "--match",
                tag_prefix + "*",
                last_revision,
            ]
        )
        if not as_tag:
            version = version[len(tag_prefix):]
    if as_json:
        print('{"current_version": "%s"}' % version)
    else:
        print(version)


def last_release_version(
    tag_prefix: Optional[str],
    as_tag: bool,
    last_revision: Optional[str],
) -> str:
    if not last_revision:
        last_revision = "HEAD"
    if tag_prefix is None:
        return run(
            [
                "git",
                "describe",
                "--tags",
                "--always",
                "--abbrev=0",
                last_revision + "^",
            ]
        )
    version = run(
        [
            "git",
            "describe",
            "--tags",
            "--always",
            "--abbrev=0",
            "--match",
            tag_prefix + "*",
            last_revision + "^",
        ]
    )
    if not as_tag:
        version = version[len(tag_prefix):]
    return version


def last_release_version_command(
    as_json: bool,
    tag_prefix: Optional[str],
    as_tag: bool,
    last_revision: Optional[str],
):
    version = last_release_version(tag_prefix, as_tag, last_revision)
    if as_json:
        print('{"last_release_version": "%s"}' % version)
    else:
        print(version)


def prepare_range(
    initial_revision: Optional[str],
    last_revision: Optional[str],
    tag_prefix: Optional[str],
) -> str:
    if not initial_revision:
        initial_revision = last_release_version(
            tag_prefix, True, last_revision
        )
    if not last_revision:
        last_revision = "HEAD"
    return "%s..%s" % (initial_revision, last_revision)


def index_without_exception(my_list, i):
    try:
        return my_list.index(i)
    except ValueError:
        return -1


def group_from_type(line_type: str) -> Optional[str]:
    if (
        line_type == "fix"
        or line_type == "refactor"
        or line_type == "docs"
        or line_type == "perf"
        or line_type == "BREAKING CHANGE"
    ):
        return "Fixes"
    if (
        line_type == "chore"
        or line_type == "ci"
        or line_type == "build"
        or line_type == "style"
        or line_type == "test"
    ):
        return "Other"
    if line_type == "skip" or line_type == "wip" or line_type == "minor":
        return None
    return "Features"


def increment_from_type(line_type: str) -> IncrementType:
    if line_type == "BREAKING CHANGE":
        return IncrementType.MAJOR
    if (
        line_type == "fix"
        or line_type == "refactor"
        or line_type == "docs"
        or line_type == "perf"
        or line_type == "BREAKING CHANGE"
        or line_type == "chore"
        or line_type == "ci"
        or line_type == "build"
        or line_type == "style"
        or line_type == "test"
    ):
        return IncrementType.PATCH
    if line_type == "skip" or line_type == "wip" or line_type == "minor":
        return IncrementType.NONE
    return IncrementType.MINOR


RELEASE_LINE_RE = re.compile(
    "^(\\w*)(?:\\(([\\w\\$\\.\\-\\*\\s]*)\\))?\\:\\s(.*)$"
)


def parse_message(message: str):
    lines = message.split("\n")
    reversed_lines = lines.copy()
    reversed_lines.reverse()

    header_delimiter_index = index_without_exception(lines, "")
    if header_delimiter_index != -1:
        footer_delimiter_index = index_without_exception(reversed_lines, "")
    else:
        footer_delimiter_index = -1

    if header_delimiter_index == -1:
        header_lines = lines
    else:
        header_lines = lines[:header_delimiter_index]
    if footer_delimiter_index == -1:
        footer_lines = []
    else:
        footer_lines = reversed_lines[:footer_delimiter_index]

    is_major = False
    notes = {}
    if footer_lines:
        for line in footer_lines:
            line = line.strip()
            delimiter = line.find(":")
            if delimiter == -1:
                break
            key = line[:delimiter].strip()
            value = line[delimiter + 1:].strip()
            notes[key] = value
            if key == "BREAKING CHANGE":
                is_major = True

    headers = []
    for line in header_lines:
        if line.startswith("-") or line.startswith("*"):
            line = line[1:]
        line = line.strip()
        parseds = RELEASE_LINE_RE.findall(line)
        if parseds:
            parsed = parseds[0]
            line_type = parsed[0].lower()
            scope = parsed[1].lower()
            if not scope:
                scope = "*"
            if line_type.endswith("!"):
                line_type = line_type[:-1]
                increment = IncrementType.MAJOR
            elif is_major:
                increment = IncrementType.MAJOR
            else:
                increment = increment_from_type(line_type)
            group = group_from_type(line_type)
            description = parsed[2]
            if "WIP" in description:
                line_type = "wip"
                group = None
                increment = IncrementType.NONE
            headers.append(
                ChangeLogLine(line_type, scope, description, group, increment)
            )
        else:
            line_type = "feat"
            increment = increment_from_type(line_type)
            group = group_from_type(line_type)
            if "WIP" in line:
                line_type = "wip"
                group = None
                increment = IncrementType.NONE
            headers.append(
                ChangeLogLine(line_type, "*", line, group, increment)
            )
    if is_major:
        increments = map(lambda x: x.increment, headers)
        commit_increment = find_increment(increments)
        if commit_increment != IncrementType.MAJOR:
            if headers:
                headers[0].increment = IncrementType.MAJOR
            else:
                line_type = "feat"
                increment = IncrementType.MAJOR
                group = group_from_type(line_type)
                if header_lines:
                    line = header_lines[0]
                else:
                    line = ""
                headers.append(
                    ChangeLogLine(line_type, "*", line, group, increment)
                )
    if headers:
        headers = headers.copy()
        headers.reverse()

    return (headers, notes)


def parse_commit(raw: RawCommit) -> CommitInfo:
    headers, notes = parse_message(raw.message)
    return CommitInfo(
        commit=raw.commit,
        author=raw.author,
        author_email=raw.author_email,
        date=raw.date,
        raw=raw.message,
        headers=headers,
        notes=notes,
    )


def filter_by_scope(commit: CommitInfo, scope: str) -> Optional[CommitInfo]:
    commit.headers = list(
        filter(lambda x: x.scope == "*" or x.scope == scope, commit.headers)
    )
    if not commit.headers:
        return None
    return commit


def find_increment(increments: List[IncrementType]) -> IncrementType:
    increment = IncrementType.NONE
    for increment in increments:
        if increment == IncrementType.MAJOR:
            increment = IncrementType.MAJOR
            break
        elif increment == IncrementType.MINOR:
            if (
                increment == IncrementType.PATCH
                or increment == IncrementType.NONE
            ):
                increment = IncrementType.MINOR
        elif increment == IncrementType.PATCH:
            if IncrementType.NONE:
                increment = IncrementType.PATCH
    return increment


def flatten(my_list):
    return functools.reduce(operator.iconcat, my_list, [])


def increment_version(last_release: str, increment: IncrementType) -> str:
    version_parts = list(filter(None, re.split("v|\\.|\\-|\\+", last_release)))
    major = int(version_parts[0])
    minor = int(version_parts[1])
    patch = int(version_parts[2])
    if increment == IncrementType.MAJOR:
        major += 1
        minor = 0
        patch = 0
    elif increment == IncrementType.MINOR:
        minor += 1
        patch = 0
    elif increment == IncrementType.PATCH:
        patch += 1
    return f"{major}.{minor}.{patch}"


def non_null(my_list):
    return filter(lambda x: x, my_list)


def prepare_parsed_info(
    tag_prefix: Optional[str],
    as_tag: bool,
    scope: Optional[str],
    initial_revision: Optional[str],
    last_revision: Optional[str],
) -> ParsedInfo:
    last_release = last_release_version(tag_prefix, True, last_revision)
    if not initial_revision:
        initial_revision = last_release
    range = prepare_range(initial_revision, last_revision, tag_prefix)

    commits_json_txt = run(["jc", "git", "log", range])

    json_array_obj = json.loads(commits_json_txt)
    raw_commits = []
    for json_obj in json_array_obj:
        raw_commit = RawCommit.from_dict(json_obj)
        raw_commits.append(raw_commit)

    parsed_commits = list(map(parse_commit, raw_commits))
    if scope and scope != "*":
        parsed_commits = list(
            non_null(map(lambda x: filter_by_scope(x, scope), parsed_commits))
        )
    all_headers = flatten(map(lambda x: x.headers if x else x, parsed_commits))
    increment = find_increment(list(map(lambda x: x.increment, all_headers)))
    if tag_prefix and last_release.startswith(tag_prefix):
        last_release = last_release[len(tag_prefix):]
    current_version = increment_version(last_release, increment)
    if as_tag and tag_prefix:
        current_version = tag_prefix + current_version
        last_release = tag_prefix + last_release

    return ParsedInfo(
        version=VersionInfo(
            last=last_release, increment=increment, current=current_version
        ),
        commits=parsed_commits,
    )


def release_version_command(
    as_json: bool,
    tag_prefix: Optional[str],
    as_tag: bool,
    scope: Optional[str],
    initial_revision: Optional[str],
    last_revision: Optional[str],
):
    version = prepare_parsed_info(
        tag_prefix, as_tag, scope, initial_revision, last_revision
    ).version
    release_version = version.current
    increment = version.increment

    if as_json:
        print(
            '{"release_version": "%s", "increment": "%s"}'
            % (release_version, increment.value)
        )
    else:
        print(release_version)


@dataclass(frozen=True)
class ReleaseLine:
    sha: str
    type: str
    scope: str
    description: str


def get_release_lines_per_group(parsed_info: ParsedInfo):
    lines_per_group = {}
    for commit in parsed_info.commits:
        for header in commit.headers:
            if header.group not in lines_per_group:
                lines_per_group[header.group] = []
            lines_per_group[header.group].append(
                ReleaseLine(
                    sha=commit.commit[:7],
                    type=header.type,
                    scope=header.scope,
                    description=header.description,
                )
            )
    return lines_per_group


def group_to_text(header: str, lines: List[ReleaseLine]) -> str:
    if not lines:
        return ""
    text_lines = [f"### {header}\n"]
    for line in lines:
        if line.scope != "*":
            scope_txt = line.scope
        else:
            scope_txt = ""
        if line.type != "feat" and line.type != "fix":
            if scope_txt:
                type_txt = f"{line.type}({scope_txt})"
            elif line.type:
                type_txt = line.type
            else:
                type_txt = scope_txt
        else:
            type_txt = scope_txt
        if type_txt:
            type_txt += ": "
        text_lines.append(f"- ({line.sha}) {type_txt}{line.description}")
    return "\n".join(text_lines)


def unique_with_order(my_list: List[ReleaseLine]) -> List[ReleaseLine]:
    return list(dict.fromkeys(my_list))


def get_group(lines_per_group, group_name):
    try:
        return unique_with_order(lines_per_group[group_name])
    except KeyError:
        return []


def format_release_notes(parsed_info: ParsedInfo) -> str:
    lines_per_group = get_release_lines_per_group(parsed_info)
    features = group_to_text(
        "Features", get_group(lines_per_group, "Features")
    )
    fixes = group_to_text("Fixes", get_group(lines_per_group, "Fixes"))
    other = group_to_text("Other", get_group(lines_per_group, "Other"))
    non_empty_list = list(filter(None, [features, fixes, other]))
    return "\n\n".join(non_empty_list)


def release_notes_command(
    as_json: bool,
    tag_prefix: Optional[str],
    as_tag: bool,
    scope: Optional[str],
    initial_revision: Optional[str],
    last_revision: Optional[str],
):
    parsed_info = prepare_parsed_info(
        tag_prefix, as_tag, scope, initial_revision, last_revision
    )

    if as_json:
        print(json.dumps(parsed_info, cls=EnhancedJSONEncoder))
    else:
        print(format_release_notes(parsed_info))


def arguments_parser(args):
    parser = argparse.ArgumentParser(
        description="""
Provides next release version and release notes from git commit messages."""
    )
    parser.add_argument(
        "-j", "--json", action="store_true", help="output in json format"
    )
    parser.add_argument(
        "-t",
        "--tag-prefix",
        help="prefix for tags (optional)",
        default=None,
        nargs="?",
    )
    parser.add_argument(
        "--tag",
        action="store_true",
        help="add tag prefix to versions (only if tag prefix is defined)",
    )
    parser.add_argument(
        "-s",
        "--scope",
        help="scope to filter release note items",
        default="*",
        nargs="?",
    )
    parser.add_argument(
        "-i",
        "--initial-revision",
        help="start range from next revision",
        default="",
        nargs="?",
    )
    parser.add_argument(
        "-l",
        "--last-revision",
        help="stop on this revision",
        default="HEAD",
        nargs="?",
    )
    subparsers = parser.add_subparsers()

    version = subparsers.add_parser(
        "version", help="Prints version of this tool"
    )
    version.set_defaults(func=lambda args: version_command(args.json))

    current_version = subparsers.add_parser(
        "currentVersion",
        help="Prints current version (useful for non-release builds)",
    )
    current_version.set_defaults(
        func=lambda args: current_version_command(
            args.json, args.tag_prefix, args.tag, args.last_revision
        )
    )

    last_version = subparsers.add_parser(
        "lastReleaseVersion", help="Prints version of last release"
    )
    last_version.set_defaults(
        func=lambda args: last_release_version_command(
            args.json, args.tag_prefix, args.tag, args.last_revision
        )
    )

    release_version = subparsers.add_parser(
        "releaseVersion",
        help="Prints version of next release from git commit messages",
    )
    release_version.set_defaults(
        func=lambda args: release_version_command(
            args.json,
            args.tag_prefix,
            args.tag,
            args.scope,
            args.initial_revision,
            args.last_revision,
        )
    )

    release_notes = subparsers.add_parser(
        "releaseNotes", help="Prints release notes from git commit messages"
    )
    release_notes.set_defaults(
        func=lambda args: release_notes_command(
            args.json,
            args.tag_prefix,
            args.tag,
            args.scope,
            args.initial_revision,
            args.last_revision,
        )
    )

    if len(args) == 0:
        parser.print_help()
        sys.exit(1)

    return parser.parse_args(args)


def main(args):
    args = arguments_parser(args)
    args.func(args)


if __name__ == "__main__":
    main(sys.argv[1:])
